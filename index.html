<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Shipping Instructions æŸ¥è©¢ - Pro</title>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet" />
        <link rel="stylesheet" href="./index.css" />
    </head>
    <body data-theme="light">
        <div class="tree-sidebar collapsed" id="tree-sidebar">
            <button class="sidebar-handle" id="sidebar-handle" type="button" aria-label="å±•é–‹æ¬„ä½æ¨¹">â˜°</button>
            <div class="tree-panel">
                <div class="tree-panel-header">
                    <div>
                        <p class="panel-kicker">Model Map</p>
                    </div>
                    <button class="sidebar-close" id="sidebar-close" type="button" aria-label="æ”¶åˆæ¨¹ç‹€é¸å–®">Ã—</button>
                </div>
                <div class="tree-scroll">
                    <ul id="tree-container" class="tree-root"></ul>
                </div>
            </div>
        </div>
        <div class="page">
            <header>
                <div class="header-text">
                    <h1>ğŸ“¦ Shipping Instructions æ¬„ä½æŸ¥è©¢</h1>
                </div>
                <div class="toggle-wrapper" aria-label="åˆ‡æ›æ¨¡å¼">
                    <span aria-hidden="true">â˜€ï¸</span>
                    <div id="dark-mode-toggle" class="dark-mode-toggle" title="åˆ‡æ›æ·±è‰²/æ·ºè‰²æ¨¡å¼"></div>
                    <span aria-hidden="true">âš«</span>
                </div>
            </header>

            <div class="toolbar">
                <div class="filters">
                    <label class="field">
                        <span>Field</span>
                        <input id="filter-field" type="search" placeholder="HSCodes" autocomplete="off" />
                    </label>
                    <label class="field">
                        <span>Type</span>
                        <select id="filter-type">
                            <option value="">(any)</option>
                            <option value="string">string</option>
                            <option value="boolean">boolean</option>
                            <option value="int">int</option>
                            <option value="float">float</option>
                            <option value="array">array</option>
                            <option value="object">object</option>
                        </select>
                    </label>
                    <!-- <label class="field">
                        <span>Description (å«ä¸­æ–‡)</span>
                        <input id="filter-description" type="search" placeholder="è¼¸å…¥è‹±æ–‡æˆ–ä¸­æ–‡é—œéµå­—" autocomplete="off" />
                    </label> -->
                    <label class="field">
                        <span>Required</span>
                        <select id="filter-required">
                            <option value="">(any)</option>
                            <option value="å¿…å¡«">å¿…å¡«</option>
                            <option value="é¸å¡«">é¸å¡«</option>
                        </select>
                    </label>
                    <label class="field">
                        <span>Enum</span>
                        <input id="filter-enum" type="search" placeholder="PRE / COL" autocomplete="off" />
                    </label>
                    <!-- <label class="field">
                        <span>Example</span>
                        <input id="filter-example" type="search" placeholder="SWB / e0559d83..." autocomplete="off" />
                    </label> -->
                </div>
                <div class="actions">
                    <button id="search-button" class="primary" type="button">ğŸš€ ç«‹å³æŸ¥è©¢</button>
                    <button id="reset-button" type="button">æ¸…é™¤æ¢ä»¶</button>
                </div>
                <div class="meta">
                    <span class="pill">
                        <span class="status-dot"></span>
                        <span id="match-count">å°šæœªæŸ¥è©¢</span>
                    </span>
                </div>
                <div class="filter-summary" id="filter-summary">ç›®å‰æ¢ä»¶ï¼šç„¡ã€‚</div>
            </div>

            <table aria-label="Shipping instruction fields">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Field</th>
                        <th>Type</th>
                        <th>Member</th>
                        <!-- <th>Description</th>
                        <th>ä¸­æ–‡èªªæ˜</th> -->
                        <th>Required</th>
                        <!-- <th>Example</th> -->
                        <th>Enum</th>
                    </tr>
                </thead>
                <tbody id="results"></tbody>
            </table>
            <div id="tooltip" class="tooltip hidden"></div>
        </div>

        <script>
            // =========================================================================
            // 1. Dark Mode é‚è¼¯ (ä¿ç•™)
            // =========================================================================
            const body = document.body;
            const toggle = document.getElementById("dark-mode-toggle");

            // æª¢æŸ¥ localStorage æˆ–ç³»çµ±åå¥½è¨­å®š
            const getInitialTheme = () => {
                const storedTheme = localStorage.getItem("theme");
                if (storedTheme) {
                    return storedTheme;
                }
                return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
            };

            const applyTheme = (theme) => {
                body.setAttribute("data-theme", theme);
                localStorage.setItem("theme", theme);
            };

            toggle.addEventListener("click", () => {
                const currentTheme = body.getAttribute("data-theme");
                const newTheme = currentTheme === "light" ? "dark" : "light";
                applyTheme(newTheme);
            });

            // åˆå§‹åŒ–ä¸»é¡Œ
            applyTheme(getInitialTheme());

            // =========================================================================
            // 2. åŸå§‹æŸ¥è©¢èˆ‡æ¸²æŸ“é‚è¼¯ (èª¿æ•´æ¸²æŸ“éƒ¨åˆ†)
            // =========================================================================
            const resultsBody = document.getElementById("results");
            const matchCount = document.getElementById("match-count");
            const filterSummary = document.getElementById("filter-summary");
            const treeSidebar = document.getElementById("tree-sidebar");
            const treeContainer = document.getElementById("tree-container");
            const sidebarHandle = document.getElementById("sidebar-handle");
            const sidebarClose = document.getElementById("sidebar-close");
            let fieldData = [];
            let dataLoaded = false;
            let loading = false;
            let treeBuilt = false;
            let activeTreeRow = null;
            // æ¨¹ç‹€é¸å–®ç›®å‰çš„é¸å–ï¼Œç”¨ä¾†é–å®šå°æ‡‰çš„ Model/Field
            let treeSelection = null;

            const filters = {
                field: document.getElementById("filter-field"),
                type: document.getElementById("filter-type"),
                // description: document.getElementById("filter-description"),
                required: document.getElementById("filter-required"),
                // example: document.getElementById("filter-example"),
                enum: document.getElementById("filter-enum"),
            };

            const translateToZh = (text = "") => {
                // é€™è£¡æ‡‰è©²æ˜¯å¯¦éš›çš„ç¿»è­¯é‚è¼¯ï¼Œä½†ç”±æ–¼ç„¡æ³•å­˜å–å¤–éƒ¨è³‡æºï¼Œæš«æ™‚ä¿æŒåŸæ¨£æˆ–ç°¡å–®è™•ç†
                return text && text.trim() ? text : "(no description)";
            };

            const escapeHtml = (str = "") => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");

            const toggleSidebar = (forceOpen) => {
                if (!treeSidebar) return;
                const isOpen = treeSidebar.classList.contains("open");
                const next = typeof forceOpen === "boolean" ? forceOpen : !isOpen;
                treeSidebar.classList.toggle("open", next);
                treeSidebar.classList.toggle("collapsed", !next);
            };

            const formatEnum = (values) => {
                if (!Array.isArray(values) || values.length === 0) return '<span class="muted">-</span>';
                return `<span class="enum-list">${values.map((v) => `<span class="enum-item">${escapeHtml(String(v))}</span>`).join("")}</span>`;
            };

            // è§£é™¤æ¨¹ç‹€ç›®å‰çš„æ¨™è¨˜ï¼ˆé¸å–èˆ‡çˆ¶å±¤é†’ç›®ï¼‰
            const clearTreeSelection = () => {
                if (!treeContainer) return;
                treeContainer.querySelectorAll(".tree-row.selected, .tree-row.selected-ancestor").forEach((el) => {
                    el.classList.remove("selected", "selected-ancestor");
                });
                activeTreeRow = null;
            };

            // å°‡çˆ¶å±¤éƒ½å¥—ç”¨é†’ç›®æ¨£å¼
            const highlightAncestors = (row) => {
                let li = row?.parentElement;
                while (li && li !== treeContainer) {
                    const parentLi = li.parentElement?.closest("li");
                    if (parentLi) {
                        const parentRow = parentLi.querySelector(":scope > .tree-row");
                        parentRow?.classList.add("selected-ancestor");
                    }
                    li = parentLi;
                }
            };

            const buildTreeData = (data = []) => {
                const root = { name: "root", key: "root", children: [] };
                const map = new Map();
                map.set("root", root);

                const ensurePathNode = (parts = []) => {
                    let parent = root;
                    const pathParts = [];
                    parts.forEach((part) => {
                        pathParts.push(part);
                        const key = pathParts.join(".");
                        if (!map.has(key)) {
                            const node = { name: part, key, children: [] };
                            map.set(key, node);
                            parent.children.push(node);
                        }
                        parent = map.get(key);
                    });
                    return parent;
                };

                data.forEach((item) => {
                    const modelParts = (item.model || "").split(".").filter(Boolean);
                    const parentNode = ensurePathNode(modelParts);
                    const fieldParts = [...modelParts, item.field].filter(Boolean);
                    if (!fieldParts.length) return;
                    const fieldKey = fieldParts.join(".");
                    if (!map.has(fieldKey)) {
                        const fieldNode = { name: item.field, key: fieldKey, children: [] };
                        map.set(fieldKey, fieldNode);
                        parentNode.children.push(fieldNode);
                    }
                    const node = map.get(fieldKey);
                    node.isField = true;
                });
                return root;
            };

            const createTreeNode = (node, depth = 0, parentKey = "root") => {
                const hasChildren = Array.isArray(node.children) && node.children.length > 0;
                const li = document.createElement("li");
                li.className = "tree-item";
                if (hasChildren) {
                    li.classList.add("collapsible");
                    li.classList.add(depth === 0 ? "expanded" : "collapsed");
                } else {
                    li.classList.add("leaf");
                }

                const row = document.createElement("div");
                row.className = "tree-row";
                row.style.setProperty("--depth", depth);
                row.dataset.key = node.key || "";
                row.dataset.name = node.name || "";
                row.dataset.parentKey = parentKey || "root";
                row.dataset.hasChildren = hasChildren ? "1" : "";
                row.innerHTML = `
                    <span class="tree-caret">${hasChildren ? "â€º" : "â€¢"}</span>
                    <span class="tree-label">${escapeHtml(node.name)}</span>
                `;
                li.appendChild(row);

                if (hasChildren) {
                    const ul = document.createElement("ul");
                    ul.className = "tree-children";
                    node.children.forEach((child) => ul.appendChild(createTreeNode(child, depth + 1, node.key)));
                    li.appendChild(ul);
                }

                return li;
            };

            const renderTreeSidebar = () => {
                if (!treeContainer || !fieldData.length) return;
                const tree = buildTreeData(fieldData);
                treeContainer.innerHTML = "";
                tree.children.forEach((child) => {
                    treeContainer.appendChild(createTreeNode(child, 0));
                });
                treeBuilt = true;
            };

            // Tooltip helpers
            const tooltipEl = document.getElementById("tooltip");
            const hideTooltip = () => {
                tooltipEl.classList.add("hidden");
            };
            const showTooltip = (html, x, y) => {
                tooltipEl.innerHTML = html;
                tooltipEl.classList.remove("hidden");
                // Position near the cursor with viewport bounds
                const padding = 12;
                const { offsetWidth, offsetHeight } = tooltipEl;
                let left = x + 12;
                let top = y + 12;
                const maxLeft = window.innerWidth - offsetWidth - padding;
                const maxTop = window.innerHeight - offsetHeight - padding;
                if (left > maxLeft) left = maxLeft;
                if (top > maxTop) top = maxTop;
                tooltipEl.style.left = `${Math.max(padding, left)}px`;
                tooltipEl.style.top = `${Math.max(padding, top)}px`;
            };

            const copyToClipboard = async (text, target) => {
                if (!text) return;
                let success = false;
                if (navigator.clipboard?.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                        success = true;
                    } catch (err) {
                        console.warn("Clipboard write failed", err);
                    }
                }
                if (!success) {
                    const textarea = document.createElement("textarea");
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand("copy");
                    } catch (err) {
                        console.warn("Fallback copy failed", err);
                    }
                    document.body.removeChild(textarea);
                }
                if (target) {
                    const rect = target.getBoundingClientRect();
                    showTooltip(`<strong>Copied</strong><p>${escapeHtml(text)}</p>`, rect.right, rect.top);
                    setTimeout(hideTooltip, 1000);
                }
            };

            const renderRows = (rows) => {
                resultsBody.innerHTML = rows
                    .map((item) => {
                        const zh = translateToZh(item.description || "");
                        const exampleHtml = item.example !== null && item.example !== undefined ? `<code>${escapeHtml(String(item.example))}</code>` : '<span class="muted">-</span>';
                        const requiredBadge = item.required ? '<span class="badge required">å¿…å¡«</span>' : '<span class="badge optional">é¸å¡«</span>';

                        const typeClass = item.type ? `field-type-${String(item.type).toLowerCase()}` : "muted";
                        const memberButton = item.member
                            ? `<button class="member-button" type="button" data-model="${escapeHtml(item.model || "")}" data-field="${escapeHtml(item.field || "")}" data-member="${escapeHtml(
                                  String(item.member)
                              )}">${escapeHtml(String(item.member))}</button>`
                            : '<span class="muted">-</span>';
                        const modelCell = item.model
                            ? `<div class="inline-copy"><span class="model-chip field-model">${escapeHtml(item.model)}</span><button class="copy-btn" type="button" data-copy="${escapeHtml(
                                  item.model
                              )}" aria-label="Copy model">ğŸ“‹</button></div>`
                            : '<span class="muted">-</span>';
                        const fieldCell = `
                            <div class="inline-copy">
                                <button class="field-tooltip" type="button" data-desc="${escapeHtml(item.description || "")}" data-desc-zh="${escapeHtml(item.description_zh || "")}">${escapeHtml(
                            item.field || ""
                        )}</button>
                                <button class="copy-btn" type="button" data-copy="${escapeHtml(item.field || "")}" aria-label="Copy field">ğŸ“‹</button>
                            </div>`;
                        return `
                        <tr>
                            <td class="nowrap">${modelCell}</td>
                            <td class="nowrap">${fieldCell}</td>
                            <td class="nowrap"><span class="field-value ${typeClass}">${escapeHtml(item.type || "")}</span></td>
                            <td class="nowrap">${memberButton}</td>
                            <td class="nowrap field-required">${requiredBadge}</td>
                            <td>${formatEnum(item.enum)}</td>
                        </tr>
                    `;
                    })
                    .join("");
                matchCount.textContent = `${rows.length} matches`;
            };

            const buildDescriptionTooltip = (desc = "", descZh = "") => {
                const safeDesc = desc && desc.trim() ? escapeHtml(desc).replace(/\n/g, "<br>") : "(no description)";
                const safeZh = descZh && descZh.trim() ? escapeHtml(descZh).replace(/\n/g, "<br>") : "(\u7121\u8AAA\u660E)";
                return `
                    <div>
                        <strong>Description</strong>
                        <p>${safeDesc}</p>
                        <strong>&#20013;&#25991;&#35498;&#26126;</strong>
                        <p>${safeZh}</p>
                    </div>
                `;
            };
            const buildMemberTooltip = (model, field) => {
                if (!model || !field) return "";
                const targetModel = `${model}.${field}`;
                const children = (fieldData || []).filter((row) => row.model === targetModel);
                if (!children.length) return "";
                const items = children
                    .map((c) => `<li>${escapeHtml(c.field || "")} | <span class="field-value field-type-${String(c.type || "").toLowerCase()}">${escapeHtml(c.type || "")}</span></li>`)
                    .join("");
                return `
                    <div>
                        <strong>${escapeHtml(targetModel)}</strong>
                        <ul>${items}</ul>
                    </div>
                `;
            };

            const fuzzyIncludes = (value, term) => (value ?? "").toString().toLowerCase().includes(term.toLowerCase());
            const requiredLabel = (val) => (val ? "true required yes å¿…å¡« å¿…è¦" : "false optional no é¸å¡« ä¸å¿…è¦");

            const filterRows = (terms) =>
                fieldData.filter((item) => {
                    const itemDescription = item.description || "";
                    const itemZhDescription = translateToZh(itemDescription);
                    const itemEnum = (item.enum || []).join(", ");
                    return (
                        (!terms.treeFieldExact || item.field === terms.treeFieldExact) &&
                        (!terms.treeModel || item.model === terms.treeModel) &&
                        (!terms.field || fuzzyIncludes(item.field, terms.field)) &&
                        (!terms.type || fuzzyIncludes(item.type, terms.type)) &&
                        // (!terms.description || fuzzyIncludes(itemDescription, terms.description) || fuzzyIncludes(itemZhDescription, terms.description)) &&
                        (!terms.required || fuzzyIncludes(requiredLabel(item.required), terms.required)) &&
                        // (!terms.example || fuzzyIncludes(item.example, terms.example)) &&
                        (!terms.enum || fuzzyIncludes(itemEnum, terms.enum))
                    );
                });

            const formatSummary = (terms) => {
                const labels = {
                    field: "Field",
                    type: "Type",
                    // description: "Description",
                    required: "Required",
                    // example: "Example",
                    enum: "Enum",
                };
                const chips = [];
                if (terms.treeModel) {
                    chips.push(`<span class="summary-chip"><strong>Model:</strong> ${escapeHtml(terms.treeModel)}</span>`);
                }
                for (const [key, label] of Object.entries(labels)) {
                    const val = terms[key];
                    if (val) {
                        chips.push(`<span class="summary-chip"><strong>${label}:</strong> ${escapeHtml(val)}</span>`);
                    }
                }
                return chips.length ? `Current filters: ${chips.join(" ")}` : "Current filters: none.";
            };

            const renderPlaceholder = (message) => {
                resultsBody.innerHTML = `<tr><td colspan="6" class="muted" style="text-align: center; padding: 30px;">${escapeHtml(message)}</td></tr>`;
            };

            const ensureData = async () => {
                if (dataLoaded) {
                    if (!treeBuilt) {
                        renderTreeSidebar();
                    }
                    return;
                }
                if (loading) return;
                loading = true;
                matchCount.textContent = "è®€å–è³‡æ–™ä¸­...";
                try {
                    const url = new URL("parsed_fields_filtered.json", window.location.href);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    fieldData = await res.json();
                    dataLoaded = true;
                    matchCount.textContent = "è³‡æ–™å·²è¼‰å…¥ï¼Œè«‹è¼¸å…¥é—œéµå­—";
                    renderTreeSidebar();
                } catch (err) {
                    resultsBody.innerHTML = `<tr><td colspan="6" style="text-align: center; color: var(--type-color-object);">ç„¡æ³•è®€å– parsed_fields_filtered.jsonï¼š${escapeHtml(
                        err.message
                    )}ã€‚è«‹æª¢æŸ¥æª”æ¡ˆä½ç½®ã€‚</td></tr>`;
                    matchCount.textContent = "è®€å–å¤±æ•—";
                    console.error(err);
                } finally {
                    loading = false;
                }
            };

            resultsBody.addEventListener("click", async (event) => {
                const copyBtn = event.target.closest(".copy-btn");
                const fieldBtn = event.target.closest(".field-tooltip");
                const memberBtn = event.target.closest(".member-button");

                if (copyBtn) {
                    await copyToClipboard(copyBtn.dataset.copy || "", copyBtn);
                    event.stopPropagation();
                    return;
                }

                if (fieldBtn) {
                    const html = buildDescriptionTooltip(fieldBtn.dataset.desc || "", fieldBtn.dataset.descZh || "");
                    showTooltip(html, event.clientX, event.clientY);
                    event.stopPropagation();
                    return;
                }

                if (memberBtn) {
                    await ensureData();
                    const html = buildMemberTooltip(memberBtn.dataset.model, memberBtn.dataset.field);
                    if (html) {
                        showTooltip(html, event.clientX, event.clientY);
                    } else {
                        hideTooltip();
                    }
                    event.stopPropagation();
                }
            });

            document.addEventListener("click", (event) => {
                if (!event.target.closest(".field-tooltip") && !event.target.closest(".member-button") && !event.target.closest("#tooltip")) {
                    hideTooltip();
                }
            });
            window.addEventListener("scroll", hideTooltip);

            // é»æ“Šæ¨¹ç‹€ç¯€é»æ™‚ï¼Œå¸¶å…¥ Field ä¸¦è‡ªå‹•æŸ¥è©¢
            treeContainer?.addEventListener("click", (event) => {
                const row = event.target.closest(".tree-row");
                if (!row) return;
                const item = row.parentElement;
                const caretClicked = !!event.target.closest(".tree-caret");

                // é»æ“Š icon åªå±•é–‹/æ”¶åˆï¼Œä¸è§¸ç™¼æŸ¥è©¢
                if (item?.classList.contains("collapsible")) {
                    item.classList.toggle("expanded");
                    item.classList.toggle("collapsed");
                    if (caretClicked) return;
                }

                clearTreeSelection();
                row.classList.add("selected");
                activeTreeRow = row;
                const selectedField = row.dataset.name || "";
                const parentKey = row.dataset.parentKey || "";
                const modelFromTree = parentKey && parentKey !== "root" ? parentKey : "";
                treeSelection = { field: selectedField, model: modelFromTree };
                filters.field.value = selectedField;
                highlightAncestors(row);
                applyFilters();
            });

            sidebarHandle?.addEventListener("click", async () => {
                toggleSidebar(!treeSidebar.classList.contains("open"));
                await ensureData();
            });

            sidebarClose?.addEventListener("click", () => toggleSidebar(false));
            document.addEventListener("click", (event) => {
                if (!treeSidebar?.classList.contains("open")) return;
                const target = event.target;
                if (treeSidebar.contains(target)) return;
                toggleSidebar(false);
            });

            const collectTerms = () => ({
                field: filters.field.value.trim(),
                type: filters.type.value,
                // description: filters.description.value.trim(),
                required: filters.required.value,
                // example: filters.example.value.trim(),
                enum: filters.enum.value.trim(),
                treeModel: treeSelection?.model || "",
                treeFieldExact: treeSelection?.field || "",
            });

            const applyFilters = async () => {
                const terms = collectTerms();
                const hasInput = Object.values(terms).some((v) => v);

                await ensureData();
                if (!dataLoaded) return;

                if (!hasInput) {
                    renderPlaceholder("Enter keywords to search (data successfully loaded).");
                    matchCount.textContent = "No query yet";
                    filterSummary.innerHTML = "Current filters: none.";
                    return;
                }

                const rows = filterRows(terms);

                filterSummary.innerHTML = formatSummary(terms);
                if (rows.length === 0) {
                    renderPlaceholder("No data found. Try adjusting keywords.");
                    matchCount.textContent = "0 matches";
                    return;
                }
                renderRows(rows);
            };

            const resetFilters = () => {
                Object.values(filters).forEach((input) => {
                    input.value = "";
                });
                treeSelection = null;
                clearTreeSelection();
                matchCount.textContent = "No query yet";
                renderPlaceholder("Cleared. Please enter keywords to search.");
                filterSummary.innerHTML = "Current filters: none.";
            };

            // äº‹ä»¶ç›£è½
            Object.values(filters).forEach((input) =>
                input.addEventListener("input", () => {
                    if (input === filters.field) {
                        // æ‰‹å‹•è¼¸å…¥ Field è¦†è“‹æ¨¹ç‹€é¸å–
                        treeSelection = null;
                        clearTreeSelection();
                    }
                    applyFilters();
                })
            );

            document.getElementById("search-button").addEventListener("click", applyFilters);
            document.getElementById("reset-button").addEventListener("click", resetFilters);

            // åˆå§‹æç¤º
            renderPlaceholder("Enter keywords to search (data loads on first search).");
        </script>
    </body>
</html>
